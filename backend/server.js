const express = require('express');
const { exec } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const util = require('util');

const app = express();
const port = 3000;

// Promisify exec for async/await
const execPromise = util.promisify(exec);

// Middleware to parse JSON bodies
app.use(express.json());

// Serve static files (for frontend access to PDFs)
app.use('/generated-pdfs', express.static(path.join(__dirname, 'generated-pdfs')));

// Ensure generated-pdfs directory exists
fs.ensureDirSync(path.join(__dirname, 'generated-pdfs'));

// API endpoint to generate PDFs
app.post('/generate-pdf', async (req, res) => {
    try {
        const { documents, companyDetails, customContent, compiledBy } = req.body;

        if (!documents || documents.length === 0) {
            return res.status(400).json({ error: 'No documents selected' });
        }

        // For simplicity, we'll generate a PDF for the first document
        // In a full implementation, you'd loop through all documents and combine PDFs
        const docId = documents[0]; // e.g., 'health-safety-policy'
        const templatePath = path.join(__dirname, '..', 'assets', 'templates', 'ohs-system', `${docId}-template.tex`);
        const outputDir = path.join(__dirname, 'generated-pdfs');
        const outputBaseName = `${docId}-${Date.now()}`;
        const outputTexPath = path.join(outputDir, `${outputBaseName}.tex`);
        const outputPdfPath = path.join(outputDir, `${outputBaseName}.pdf`);

        // Read the LaTeX template
        let template = await fs.readFile(templatePath, 'utf-8');

        // Replace placeholders with user inputs
        template = template
            .replace('{{COMPANY_NAME}}', companyDetails.name || 'N/A')
            .replace('{{COMPANY_ADDRESS}}', companyDetails.address || 'N/A')
            .replace('{{COMPANY_CONTACT}}', companyDetails.contactNumber || 'N/A')
            .replace('{{COMPANY_EMAIL}}', companyDetails.email || 'N/A')
            .replace('{{CEO_NAME}}', companyDetails.ceoName || 'N/A')
            .replace('{{COIDA_REG}}', companyDetails.coidaReg || 'N/A')
            .replace('{{CUSTOM_CONTENT}}', customContent || 'No custom content provided.')
            .replace('{{COMPILED_BY_NAME}}', compiledBy.name || 'N/A')
            .replace('{{COMPILED_BY_CONTACT}}', compiledBy.contactNumber || 'N/A')
            .replace('{{COMPILED_BY_EMAIL}}', compiledBy.email || 'N/A')
            .replace('{{COMPILED_BY_ROLE}}', compiledBy.role || 'N/A')
            .replace('{{DATE}}', new Date().toISOString().split('T')[0])
            .replace('{{REVISION}}', '1.0');

        // Write the modified LaTeX to a temporary file
        await fs.writeFile(outputTexPath, template);

        // Run latexmk to generate the PDF
        await execPromise(`latexmk -pdf -output-directory=${outputDir} ${outputTexPath}`);

        // Clean up auxiliary files generated by latexmk
        await execPromise(`latexmk -c -output-directory=${outputDir} ${outputTexPath}`);

        // Send the PDF file as a response
        res.download(outputPdfPath, `${docId}.pdf`, async (err) => {
            if (err) {
                console.error('Error sending PDF:', err);
                res.status(500).json({ error: 'Failed to send PDF' });
            }

            // Clean up temporary files
            await fs.remove(outputTexPath);
            await fs.remove(outputPdfPath);
            const auxFiles = ['aux', 'log', 'fls', 'fdb_latexmk'].map(ext => path.join(outputDir, `${outputBaseName}.${ext}`));
            for (const file of auxFiles) {
                if (await fs.pathExists(file)) await fs.remove(file);
            }
        });
    } catch (error) {
        console.error('Error generating PDF:', error);
        res.status(500).json({ error: 'Failed to generate PDF' });
    }
});

// Start the server
app.listen(port, () => {
    console.log(`Server running on http://localhost:${port}`);
});
