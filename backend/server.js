const express = require('express');
const { exec } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const util = require('util');
const archiver = require('archiver');

const app = express();
const port = 3000;

// Promisify exec for async/await
const execPromise = util.promisify(exec);

// Middleware to parse JSON bodies
app.use(express.json());

// Serve static files (for frontend access to PDFs and ZIPs)
app.use('/generated-pdfs', express.static(path.join(__dirname, 'generated-pdfs')));

// Ensure generated-pdfs directory exists
fs.ensureDirSync(path.join(__dirname, 'generated-pdfs'));

// API endpoint to generate PDFs and return as ZIP
app.post('/generate-pdf', async (req, res) => {
    try {
        const { documents, companyDetails, customContent, compiledBy } = req.body;

        if (!documents || documents.length === 0) {
            return res.status(400).json({ error: 'No documents selected' });
        }

        const outputDir = path.join(__dirname, 'generated-pdfs');
        const zipBaseName = `ohs-documents-${Date.now()}`;
        const zipPath = path.join(outputDir, `${zipBaseName}.zip`);
        const pdfPaths = [];

        // Generate PDFs for each document
        for (const docId of documents) {
            const templatePath = path.join(__dirname, '..', 'assets', 'templates', 'ohs-system', `${docId}-template.tex`);
            const outputBaseName = `${docId}-${Date.now()}`;
            const outputTexPath = path.join(outputDir, `${outputBaseName}.tex`);
            const outputPdfPath = path.join(outputDir, `${outputBaseName}.pdf`);

            // Check if template exists
            if (!await fs.pathExists(templatePath)) {
                console.warn(`Template for ${docId} not found, skipping.`);
                continue;
            }

            // Read the LaTeX template
            let template = await fs.readFile(templatePath, 'utf-8');

            // Replace placeholders with user inputs
            template = template
                .replace('{{COMPANY_NAME}}', companyDetails.name || 'N/A')
                .replace('{{COMPANY_ADDRESS}}', companyDetails.address || 'N/A')
                .replace('{{COMPANY_CONTACT}}', companyDetails.contactNumber || 'N/A')
                .replace('{{COMPANY_EMAIL}}', companyDetails.email || 'N/A')
                .replace('{{CEO_NAME}}', companyDetails.ceoName || 'N/A')
                .replace('{{COIDA_REG}}', companyDetails.coidaReg || 'N/A')
                .replace('{{CUSTOM_CONTENT}}', customContent || 'No custom content provided.')
                .replace('{{COMPILED_BY_NAME}}', compiledBy.name || 'N/A')
                .replace('{{COMPILED_BY_CONTACT}}', compiledBy.contactNumber || 'N/A')
                .replace('{{COMPILED_BY_EMAIL}}', compiledBy.email || 'N/A')
                .replace('{{COMPILED_BY_ROLE}}', compiledBy.role || 'N/A')
                .replace('{{DATE}}', new Date().toISOString().split('T')[0])
                .replace('{{REVISION}}', '1.0');

            // Write the modified LaTeX to a temporary file
            await fs.writeFile(outputTexPath, template);

            // Run latexmk to generate the PDF
            await execPromise(`latexmk -pdf -output-directory=${outputDir} ${outputTexPath}`);

            // Clean up auxiliary files generated by latexmk
            await execPromise(`latexmk -c -output-directory=${outputDir} ${outputTexPath}`);

            pdfPaths.push({ path: outputPdfPath, name: `${docId}.pdf` });

            // Clean up the temporary .tex file
            await fs.remove(outputTexPath);
        }

        if (pdfPaths.length === 0) {
            return res.status(400).json({ error: 'No PDFs generated. Check if templates exist for selected documents.' });
        }

        // Create a ZIP file containing all PDFs
        const output = fs.createWriteStream(zipPath);
        const archive = archiver('zip', { zlib: { level: 9 } });

        // Pipe the archive to the output file
        archive.pipe(output);

        // Add each PDF to the ZIP
        for (const pdf of pdfPaths) {
            archive.file(pdf.path, { name: pdf.name });
        }

        // Finalize the ZIP and send it
        await archive.finalize();

        // Wait for the ZIP file to be fully written
        await new Promise(resolve => output.on('close', resolve));

        // Send the ZIP file as a response
        res.download(zipPath, 'ohs-documents.zip', async (err) => {
            if (err) {
                console.error('Error sending ZIP:', err);
                res.status(500).json({ error: 'Failed to send ZIP file' });
            }

            // Clean up temporary files
            await fs.remove(zipPath);
            for (const pdf of pdfPaths) {
                await fs.remove(pdf.path);
                const auxFiles = ['aux', 'log', 'fls', 'fdb_latexmk'].map(ext => path.join(outputDir, `${path.basename(pdf.path, '.pdf')}.${ext}`));
                for (const file of auxFiles) {
                    if (await fs.pathExists(file)) await fs.remove(file);
                }
            }
        });
    } catch (error) {
        console.error('Error generating PDFs:', error);
        res.status(500).json({ error: 'Failed to generate PDFs' });
    }
});

// Start the server
app.listen(port, () => {
    console.log(`Server running on http://localhost:${port}`);
});
